#include <po_hi_gqueue.h>
#include <deployment.h>
#include <po_hi_types.h>
#include <request.h>
#include <types.h>
#include "subprograms.h"
#include <activity.h>
#include <po_hi_task.h>
#include <po_hi_main.h>
#include <po_hi_transport.h>
/*****************************************************/
/*  This file was automatically generated by Ocarina */
/*  Do NOT hand-modify this file, as your            */
/*  changes will be lost when you re-run Ocarina     */
/*****************************************************/
__po_hi_port_t __po_hi_the_video_thread_person_on_video_detected_local_destinations[1] = {the_access_control_thread_global_person_on_video_detected};
__po_hi_uint8_t __po_hi_the_video_thread_woffsets[__po_hi_the_video_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_video_thread_offsets[__po_hi_the_video_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_video_thread_used_size[__po_hi_the_video_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_video_thread_empties[__po_hi_the_video_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_video_thread_first[__po_hi_the_video_thread_nb_ports];
__po_hi_request_t __po_hi_the_video_thread_recent[__po_hi_the_video_thread_nb_ports];
__po_hi_port_t __po_hi_the_video_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_video_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_video_thread_history[0];
__po_hi_uint8_t __po_hi_the_video_thread_n_dest[__po_hi_the_video_thread_nb_ports] = {0,1};
__po_hi_int8_t __po_hi_the_video_thread_fifo_size[__po_hi_the_video_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_video_thread_destinations[__po_hi_the_video_thread_nb_ports] = {NULL,__po_hi_the_video_thread_person_on_video_detected_local_destinations};

/*!
 * \fn void the_video_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_video_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_video_thread_deliver) stores the incoming request for the 
 * taskthe_video_thread
 */
void the_video_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_video_thread_global_video_stream:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_video_thread_k, the_video_thread_local_video_stream, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_video_thread_job (void)
 * \brief Function executed by the task the_video_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_video_thread*/
/*  Get the IN ports values*/
void* the_video_thread_job (void)
{
  __po_hi_request_t static video_stream_request;
  threads__booleanvalue person_on_video_detected_request_var;
  __po_hi_request_t person_on_video_detected_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_video_thread_k, __po_hi_the_video_thread_nb_ports, __po_hi_the_video_thread_queue, __po_hi_the_video_thread_fifo_size, __po_hi_the_video_thread_first, __po_hi_the_video_thread_offsets, __po_hi_the_video_thread_woffsets, __po_hi_the_video_thread_n_dest, __po_hi_the_video_thread_destinations, __po_hi_the_video_thread_used_size, __po_hi_the_video_thread_history, __po_hi_the_video_thread_recent, __po_hi_the_video_thread_empties, __po_hi_the_video_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_video_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_video_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_video_thread_k, the_video_thread_local_video_stream))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_video_thread_k, the_video_thread_local_video_stream, &(video_stream_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_video_thread_k, the_video_thread_local_video_stream);

    }
    /*  Call implementation*/
    threads__video_processing_spg (video_stream_request.vars.the_video_thread_global_video_stream.the_video_thread_global_video_stream, &(person_on_video_detected_request_var));
    /*  Set the OUT port values*/
    person_on_video_detected_request.vars.the_video_thread_global_person_on_video_detected.the_video_thread_global_person_on_video_detected = person_on_video_detected_request_var;
    person_on_video_detected_request.port = the_video_thread_global_person_on_video_detected;
    __po_hi_gqueue_store_out (standard_room_controller_the_video_thread_k, the_video_thread_local_person_on_video_detected, &(person_on_video_detected_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_video_thread_k, the_video_thread_global_person_on_video_detected);
    __po_hi_wait_for_next_period (standard_room_controller_the_video_thread_k);
  }
}

__po_hi_port_t __po_hi_the_door_sensor_thread_person_entered_local_destinations[1] = {the_access_control_thread_global_person_entered};
__po_hi_uint8_t __po_hi_the_door_sensor_thread_woffsets[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_door_sensor_thread_offsets[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_door_sensor_thread_used_size[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_door_sensor_thread_empties[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_door_sensor_thread_first[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_request_t __po_hi_the_door_sensor_thread_recent[__po_hi_the_door_sensor_thread_nb_ports];
__po_hi_port_t __po_hi_the_door_sensor_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_door_sensor_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_door_sensor_thread_history[0];
__po_hi_uint8_t __po_hi_the_door_sensor_thread_n_dest[__po_hi_the_door_sensor_thread_nb_ports] = {0,1};
__po_hi_int8_t __po_hi_the_door_sensor_thread_fifo_size[__po_hi_the_door_sensor_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_door_sensor_thread_destinations[__po_hi_the_door_sensor_thread_nb_ports] = {NULL,__po_hi_the_door_sensor_thread_person_entered_local_destinations};

/*!
 * \fn void the_door_sensor_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_door_sensor_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_door_sensor_thread_deliver) stores the incoming request for the 
 * taskthe_door_sensor_thread
 */
void the_door_sensor_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_door_sensor_thread_global_door_state:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_local_door_state, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_door_sensor_thread_job (void)
 * \brief Function executed by the task the_door_sensor_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_door_sensor_thread*/
/*  Get the IN ports values*/
void* the_door_sensor_thread_job (void)
{
  __po_hi_request_t static door_state_request;
  threads__booleanvalue door_opened_request_var;
  __po_hi_request_t person_entered_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_door_sensor_thread_k, __po_hi_the_door_sensor_thread_nb_ports, __po_hi_the_door_sensor_thread_queue, __po_hi_the_door_sensor_thread_fifo_size, __po_hi_the_door_sensor_thread_first, __po_hi_the_door_sensor_thread_offsets, __po_hi_the_door_sensor_thread_woffsets, __po_hi_the_door_sensor_thread_n_dest, __po_hi_the_door_sensor_thread_destinations, __po_hi_the_door_sensor_thread_used_size, __po_hi_the_door_sensor_thread_history, __po_hi_the_door_sensor_thread_recent, __po_hi_the_door_sensor_thread_empties, __po_hi_the_door_sensor_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_door_sensor_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_door_sensor_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_local_door_state))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_local_door_state, &(door_state_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_local_door_state);

    }
    /*  Call implementation*/
    threads__door_sensor_spg (door_state_request.vars.the_door_sensor_thread_global_door_state.the_door_sensor_thread_global_door_state, &(door_opened_request_var));
    /*  Set the OUT port values*/
    person_entered_request.vars.the_door_sensor_thread_global_person_entered.the_door_sensor_thread_global_person_entered = person_entered_request_var;
    person_entered_request.port = the_door_sensor_thread_global_person_entered;
    __po_hi_gqueue_store_out (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_local_person_entered, &(person_entered_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_door_sensor_thread_k, the_door_sensor_thread_global_person_entered);
    __po_hi_wait_for_next_period (standard_room_controller_the_door_sensor_thread_k);
  }
}

__po_hi_port_t __po_hi_the_window_sensor_thread_window_opened_local_destinations[1] = {the_access_control_thread_global_person_entered};
__po_hi_uint8_t __po_hi_the_window_sensor_thread_woffsets[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_window_sensor_thread_offsets[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_window_sensor_thread_used_size[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_window_sensor_thread_empties[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_window_sensor_thread_first[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_request_t __po_hi_the_window_sensor_thread_recent[__po_hi_the_window_sensor_thread_nb_ports];
__po_hi_port_t __po_hi_the_window_sensor_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_window_sensor_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_window_sensor_thread_history[0];
__po_hi_uint8_t __po_hi_the_window_sensor_thread_n_dest[__po_hi_the_window_sensor_thread_nb_ports] = {0,1};
__po_hi_int8_t __po_hi_the_window_sensor_thread_fifo_size[__po_hi_the_window_sensor_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_window_sensor_thread_destinations[__po_hi_the_window_sensor_thread_nb_ports] = {NULL,__po_hi_the_window_sensor_thread_window_opened_local_destinations};

/*!
 * \fn void the_window_sensor_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_window_sensor_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_window_sensor_thread_deliver) stores the incoming request for the 
 * taskthe_window_sensor_thread
 */
void the_window_sensor_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_window_sensor_thread_global_window_state:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_local_window_state, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_window_sensor_thread_job (void)
 * \brief Function executed by the task the_window_sensor_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_window_sensor_thread*/
/*  Get the IN ports values*/
void* the_window_sensor_thread_job (void)
{
  __po_hi_request_t static window_state_request;
  threads__booleanvalue window_opened_request_var;
  __po_hi_request_t window_opened_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_window_sensor_thread_k, __po_hi_the_window_sensor_thread_nb_ports, __po_hi_the_window_sensor_thread_queue, __po_hi_the_window_sensor_thread_fifo_size, __po_hi_the_window_sensor_thread_first, __po_hi_the_window_sensor_thread_offsets, __po_hi_the_window_sensor_thread_woffsets, __po_hi_the_window_sensor_thread_n_dest, __po_hi_the_window_sensor_thread_destinations, __po_hi_the_window_sensor_thread_used_size, __po_hi_the_window_sensor_thread_history, __po_hi_the_window_sensor_thread_recent, __po_hi_the_window_sensor_thread_empties, __po_hi_the_window_sensor_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_window_sensor_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_window_sensor_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_local_window_state))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_local_window_state, &(window_state_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_local_window_state);

    }
    /*  Call implementation*/
    threads__window_sensor_spg (window_state_request.vars.the_window_sensor_thread_global_window_state.the_window_sensor_thread_global_window_state, &(window_opened_request_var));
    /*  Set the OUT port values*/
    window_opened_request.vars.the_window_sensor_thread_global_window_opened.the_window_sensor_thread_global_window_opened = window_opened_request_var;
    window_opened_request.port = the_window_sensor_thread_global_window_opened;
    __po_hi_gqueue_store_out (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_local_window_opened, &(window_opened_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_window_sensor_thread_k, the_window_sensor_thread_global_window_opened);
    __po_hi_wait_for_next_period (standard_room_controller_the_window_sensor_thread_k);
  }
}

__po_hi_port_t __po_hi_the_pin_device_thread_is_pin_correct_local_destinations[1] = {the_access_control_thread_global_is_pin_correct};
__po_hi_uint8_t __po_hi_the_pin_device_thread_woffsets[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_pin_device_thread_offsets[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_pin_device_thread_used_size[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_pin_device_thread_empties[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_pin_device_thread_first[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_request_t __po_hi_the_pin_device_thread_recent[__po_hi_the_pin_device_thread_nb_ports];
__po_hi_port_t __po_hi_the_pin_device_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_pin_device_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_pin_device_thread_history[0];
__po_hi_uint8_t __po_hi_the_pin_device_thread_n_dest[__po_hi_the_pin_device_thread_nb_ports] = {0,1};
__po_hi_int8_t __po_hi_the_pin_device_thread_fifo_size[__po_hi_the_pin_device_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_pin_device_thread_destinations[__po_hi_the_pin_device_thread_nb_ports] = {NULL,__po_hi_the_pin_device_thread_is_pin_correct_local_destinations};

/*!
 * \fn void the_pin_device_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_pin_device_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_pin_device_thread_deliver) stores the incoming request for the 
 * taskthe_pin_device_thread
 */
void the_pin_device_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_pin_device_thread_global_entered_pin:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_local_entered_pin, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_pin_device_thread_job (void)
 * \brief Function executed by the task the_pin_device_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_pin_device_thread*/
/*  Get the IN ports values*/
void* the_pin_device_thread_job (void)
{
  __po_hi_request_t static entered_pin_request;
  threads__booleanvalue is_pin_correct_request_var;
  __po_hi_request_t is_pin_correct_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_pin_device_thread_k, __po_hi_the_pin_device_thread_nb_ports, __po_hi_the_pin_device_thread_queue, __po_hi_the_pin_device_thread_fifo_size, __po_hi_the_pin_device_thread_first, __po_hi_the_pin_device_thread_offsets, __po_hi_the_pin_device_thread_woffsets, __po_hi_the_pin_device_thread_n_dest, __po_hi_the_pin_device_thread_destinations, __po_hi_the_pin_device_thread_used_size, __po_hi_the_pin_device_thread_history, __po_hi_the_pin_device_thread_recent, __po_hi_the_pin_device_thread_empties, __po_hi_the_pin_device_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_pin_device_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_pin_device_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_local_entered_pin))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_local_entered_pin, &(entered_pin_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_local_entered_pin);

    }
    /*  Call implementation*/
    threads__pin_device_spg (entered_pin_request.vars.the_pin_device_thread_global_entered_pin.the_pin_device_thread_global_entered_pin, &(is_pin_correct_request_var));
    /*  Set the OUT port values*/
    is_pin_correct_request.vars.the_pin_device_thread_global_is_pin_correct.the_pin_device_thread_global_is_pin_correct = is_pin_correct_request_var;
    is_pin_correct_request.port = the_pin_device_thread_global_is_pin_correct;
    __po_hi_gqueue_store_out (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_local_is_pin_correct, &(is_pin_correct_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_pin_device_thread_k, the_pin_device_thread_global_is_pin_correct);
    __po_hi_wait_for_next_period (standard_room_controller_the_pin_device_thread_k);
  }
}

__po_hi_port_t __po_hi_the_movement_sensor_thread_person_in_room_local_destinations[1] = {the_access_control_thread_global_person_entered};
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_woffsets[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_offsets[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_used_size[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_empties[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_first[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_request_t __po_hi_the_movement_sensor_thread_recent[__po_hi_the_movement_sensor_thread_nb_ports];
__po_hi_port_t __po_hi_the_movement_sensor_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_movement_sensor_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_movement_sensor_thread_history[0];
__po_hi_uint8_t __po_hi_the_movement_sensor_thread_n_dest[__po_hi_the_movement_sensor_thread_nb_ports] = {0,1};
__po_hi_int8_t __po_hi_the_movement_sensor_thread_fifo_size[__po_hi_the_movement_sensor_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_movement_sensor_thread_destinations[__po_hi_the_movement_sensor_thread_nb_ports] = {NULL,__po_hi_the_movement_sensor_thread_person_in_room_local_destinations};

/*!
 * \fn void the_movement_sensor_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_movement_sensor_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_movement_sensor_thread_deliver) stores the incoming request for the 
 * taskthe_movement_sensor_thread
 */
void the_movement_sensor_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_movement_sensor_thread_global_movement_data:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_local_movement_data, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_movement_sensor_thread_job (void)
 * \brief Function executed by the task the_movement_sensor_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_movement_sensor_thread*/
/*  Get the IN ports values*/
void* the_movement_sensor_thread_job (void)
{
  __po_hi_request_t static movement_data_request;
  threads__booleanvalue person_in_room_request_var;
  __po_hi_request_t person_in_room_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_movement_sensor_thread_k, __po_hi_the_movement_sensor_thread_nb_ports, __po_hi_the_movement_sensor_thread_queue, __po_hi_the_movement_sensor_thread_fifo_size, __po_hi_the_movement_sensor_thread_first, __po_hi_the_movement_sensor_thread_offsets, __po_hi_the_movement_sensor_thread_woffsets, __po_hi_the_movement_sensor_thread_n_dest, __po_hi_the_movement_sensor_thread_destinations, __po_hi_the_movement_sensor_thread_used_size, __po_hi_the_movement_sensor_thread_history, __po_hi_the_movement_sensor_thread_recent, __po_hi_the_movement_sensor_thread_empties, __po_hi_the_movement_sensor_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_movement_sensor_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_movement_sensor_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_local_movement_data))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_local_movement_data, &(movement_data_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_local_movement_data);

    }
    /*  Call implementation*/
    threads__movement_sensor_spg (movement_data_request.vars.the_movement_sensor_thread_global_movement_data.the_movement_sensor_thread_global_movement_data, &(person_in_room_request_var));
    /*  Set the OUT port values*/
    person_in_room_request.vars.the_movement_sensor_thread_global_person_in_room.the_movement_sensor_thread_global_person_in_room = person_in_room_request_var;
    person_in_room_request.port = the_movement_sensor_thread_global_person_in_room;
    __po_hi_gqueue_store_out (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_local_person_in_room, &(person_in_room_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_movement_sensor_thread_k, the_movement_sensor_thread_global_person_in_room);
    __po_hi_wait_for_next_period (standard_room_controller_the_movement_sensor_thread_k);
  }
}

__po_hi_port_t __po_hi_the_access_control_thread_access_type_local_destinations[1] = {the_alarm_control_thread_global_access_type};
__po_hi_uint8_t __po_hi_the_access_control_thread_woffsets[__po_hi_the_access_control_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_access_control_thread_offsets[__po_hi_the_access_control_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_access_control_thread_used_size[__po_hi_the_access_control_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_access_control_thread_empties[__po_hi_the_access_control_thread_nb_ports];
__po_hi_uint8_t __po_hi_the_access_control_thread_first[__po_hi_the_access_control_thread_nb_ports];
__po_hi_request_t __po_hi_the_access_control_thread_recent[__po_hi_the_access_control_thread_nb_ports];
__po_hi_port_t __po_hi_the_access_control_thread_queue[0 * sizeof (__po_hi_request_t)];
__po_hi_uint16_t __po_hi_the_access_control_thread_total_fifo_size = 0;
__po_hi_local_port_t __po_hi_the_access_control_thread_history[0];
__po_hi_uint8_t __po_hi_the_access_control_thread_n_dest[__po_hi_the_access_control_thread_nb_ports] = {0,0,0,1};
__po_hi_int8_t __po_hi_the_access_control_thread_fifo_size[__po_hi_the_access_control_thread_nb_ports] = {__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_INDATA,__PO_HI_GQUEUE_FIFO_OUT};
__po_hi_port_t* __po_hi_the_access_control_thread_destinations[__po_hi_the_access_control_thread_nb_ports] = {NULL,NULL,NULL,__po_hi_the_access_control_thread_access_type_local_destinations};

/*!
 * \fn void the_access_control_thread_deliver (__po_hi_request_t* request)
 * \brief Function that delivers requests to the task the_access_control_thread
 *
 * When the generated application received a request, it calls a main delivery
 *  function that redirects to localfunctions for each task. This function 
 * (the_access_control_thread_deliver) stores the incoming request for the 
 * taskthe_access_control_thread
 */
void the_access_control_thread_deliver 
    (__po_hi_request_t* request)
{

  switch (request->port)
  {
    case the_access_control_thread_global_is_pin_correct:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_is_pin_correct, request);

      break;
    }
    case the_access_control_thread_global_person_on_video_detected:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_on_video_detected, request);

      break;
    }
    case the_access_control_thread_global_person_entered:
    {
      __po_hi_gqueue_store_in (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_entered, request);

      break;
    }
    default:
    {
      break;
    }
  }
}


/*!
 * \fn void* the_access_control_thread_job (void)
 * \brief Function executed by the task the_access_control_thread
 *
 * This function is executed as soon as the task  is created. It performs the 
 * following operations:  Receive incoming data,  Execute tasks subprograms,  
 * Send output data.
 */
/*  Periodic task : the_access_control_thread*/
/*  Get the IN ports values*/
void* the_access_control_thread_job (void)
{
  __po_hi_request_t static is_pin_correct_request;
  __po_hi_request_t static person_on_video_detected_request;
  __po_hi_request_t static person_entered_request;
  threads__access_type access_type_request_var;
  __po_hi_request_t access_type_request;
  __po_hi_int32_t error;

  __po_hi_gqueue_init (standard_room_controller_the_access_control_thread_k, __po_hi_the_access_control_thread_nb_ports, __po_hi_the_access_control_thread_queue, __po_hi_the_access_control_thread_fifo_size, __po_hi_the_access_control_thread_first, __po_hi_the_access_control_thread_offsets, __po_hi_the_access_control_thread_woffsets, __po_hi_the_access_control_thread_n_dest, __po_hi_the_access_control_thread_destinations, __po_hi_the_access_control_thread_used_size, __po_hi_the_access_control_thread_history, __po_hi_the_access_control_thread_recent, __po_hi_the_access_control_thread_empties, __po_hi_the_access_control_thread_total_fifo_size);
  
/*!
 * Waiting for other tasks initialization
 */
  __po_hi_wait_initialization ();
  __po_hi_compute_next_period (standard_room_controller_the_access_control_thread_k);
  
/*!
 * Waiting for the first dispatch instant
 */
  __po_hi_wait_for_next_period (standard_room_controller_the_access_control_thread_k);
  
/*!
 * Task body
 */
  while (1)
  {
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_is_pin_correct))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_is_pin_correct, &(is_pin_correct_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_is_pin_correct);

    }
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_on_video_detected))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_on_video_detected, &(person_on_video_detected_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_on_video_detected);

    }
    /* :: Yes if commentary :: */if (__po_hi_gqueue_get_count (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_entered))
    {
          __po_hi_gqueue_get_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_entered, &(person_entered_request));
      __po_hi_gqueue_next_value (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_person_entered);

    }
    /*  Call implementation*/
    threads__access_control_spg (is_pin_correct_request.vars.the_access_control_thread_global_is_pin_correct.the_access_control_thread_global_is_pin_correct, person_on_video_detected_request.vars.the_access_control_thread_global_person_on_video_detected.the_access_control_thread_global_person_on_video_detected, person_entered_request.vars.the_access_control_thread_global_person_entered.the_access_control_thread_global_person_entered, &(access_type_request_var));
    /*  Set the OUT port values*/
    access_type_request.vars.the_access_control_thread_global_access_type.the_access_control_thread_global_access_type = access_type_request_var;
    access_type_request.port = the_access_control_thread_global_access_type;
    __po_hi_gqueue_store_out (standard_room_controller_the_access_control_thread_k, the_access_control_thread_local_access_type, &(access_type_request));
    /*  Send the OUT ports*/
    error =
     __po_hi_send_output (standard_room_controller_the_access_control_thread_k, the_access_control_thread_global_access_type);
    __po_hi_wait_for_next_period (standard_room_controller_the_access_control_thread_k);
  }
}


/*!
 * \fn void __po_hi_main_deliver (__po_hi_request_t* request)
 * \brief Used to deliver request to the appropriate ports
 *
 * This function takes a request as argument (\arg request) and calls the 
 * appropriate function for its delivery.To specify which function should be 
 * called, it extracts the receiver entity using the destination port.
 */
void __po_hi_main_deliver 
    (__po_hi_request_t* request)
{
  __po_hi_entity_t entity;

  entity = __po_hi_get_entity_from_global_port (request->port);
  switch (entity)
  {
    case standard_room_controller_the_video_thread_k_entity:
    {
      the_video_thread_deliver (request);

      break;
    }
    case standard_room_controller_the_door_sensor_thread_k_entity:
    {
      the_door_sensor_thread_deliver (request);

      break;
    }
    case standard_room_controller_the_window_sensor_thread_k_entity:
    {
      the_window_sensor_thread_deliver (request);

      break;
    }
    case standard_room_controller_the_pin_device_thread_k_entity:
    {
      the_pin_device_thread_deliver (request);

      break;
    }
    case standard_room_controller_the_movement_sensor_thread_k_entity:
    {
      the_movement_sensor_thread_deliver (request);

      break;
    }
    case standard_room_controller_the_access_control_thread_k_entity:
    {
      the_access_control_thread_deliver (request);

      break;
    }
    default:
    {
      break;
    }
  }
}


