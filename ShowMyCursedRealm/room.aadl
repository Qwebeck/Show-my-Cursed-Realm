package room
public
with threads;
with deployment;
	
	
	device camera
		features
			video_stream: out data port threads::Video_Stream;
			camera_on_off: in event port;
	end camera;
	
	device movement_sensor
		features
			movement_data: out data port threads::BooleanValue;
	end movement_sensor;
	
	device pin_lock
		features
			entered_pin: out data port threads::Pin;
	end pin_lock;	
	
	device door_sensor
		features
			state: out data port threads::Door_State;
	end door_sensor;
	device window_sensor
		features
			state: out data port threads::Window_State;
	end window_sensor;

	
	  -- The bus ensures communications between the antenna and the main
	  -- process stored in memory
	
	  BUS mem_bus
	  END mem_bus;
	  
	  PROCESSOR cpu
	  FEATURES
	    mem_bus : REQUIRES BUS ACCESS mem_bus;
	  PROPERTIES
	   Scheduling_protocol => (posix_1003_highest_priority_first_protocol);
	   Deployment::Execution_Platform => Native;
	  END cpu;

  	MEMORY RAM
	  FEATURES
	    mem_bus : REQUIRES BUS ACCESS mem_bus;
	  END RAM;
		
	process room_controller
		-- to jest jakiś software który steruje całym naszym systemem.
		-- ten software dostaje jakieś dane (in event/data port) i na podstawie 
		-- tych danych decyduje o tym, czy w pokoju jest jakaś osoba.
		-- W jaki sposób on to robi, my nie mamy żadnego pojęcia, ponieważ to nie jest zadanie AADL.
		-- Wiemy tylko to, że on to robi i wiemy jakie dane on do tego potrzbuje.

			
		features			
			person_in: out event port;
			door_state: in data port threads::Door_State;
			window_state: in data port threads::Window_State;
			movement_data: in data port threads::BooleanValue;
			video_stream: in data port threads::Video_Stream;
			camera_on: out event port;
			entered_pin: in data port threads::Pin;
	end room_controller;
	
	process implementation room_controller.impl
		subcomponents
			the_video_thread: thread threads::video_thread.i;
			the_door_sensor_thread: thread threads::door_sensor_thread.i;
			the_window_sensor_thread: thread threads::window_sensor_thread.i;
			the_pin_device_thread: thread threads::pin_device_thread.i;
			the_movement_sensor_thread: thread threads::movement_sensor_thread.i;
		connections
			c0: port video_stream -> the_video_thread.video_stream;
			c1: port window_state -> the_window_sensor_thread.window_state;
			c2: port door_state -> the_door_sensor_thread.door_state;
			c3: port the_door_sensor_thread.intruder_entered -> person_in;
			c4: port the_window_sensor_thread.window_opened -> person_in;
			c5: port entered_pin -> the_pin_device_thread.entered_pin;
			c7: port the_pin_device_thread.too_many_incorrect_tries -> person_in;
			c8: port movement_data -> the_movement_sensor_thread.movement_data;
			c9: port the_movement_sensor_thread.unauthorized_movement_detected -> person_in;
			
			--TODO: camera_on zapiąć
			

	end room_controller.impl;
	
	system room
		-- interfejs który opisuje to jak działa system monitoringu w naszym pokóju.  
		features
			person_in: out event port;
	end room;
	
	system implementation room.standard_room
		subcomponents -- tutaj definiujemy to jakie urządzenia znajdują się w naszym pokoju. 
		-- Nie definiujemy tego w interfejsie ponieważ nie są to dane które powinny być widoczne na zewnątrz.
			camera: device camera;
			movement_sensor: device movement_sensor;
			window_sensor: device window_sensor;
			door_sensor: device door_sensor;
			controller: process room_controller.impl;
			pin_device: device pin_lock;
			
		    cpu : PROCESSOR cpu;
			mem_bus: BUS mem_bus;
			RAM: MEMORY RAM;
		connections
			-- tutaj pokazujemy to w jaki sposób nasze urządzenia są połączone ze sobą i jak między nimi przepływają dane
			C1: port camera.video_stream -> controller.video_stream; 
			C6: port controller.camera_on -> camera.camera_on_off; 
			C7: port pin_device.entered_pin -> controller.entered_pin;
			C2: port movement_sensor.movement_data -> controller.movement_data;
			C3: port window_sensor.state-> controller.window_state;
			C4: port door_sensor.state-> controller.door_state;
			C5: port controller.person_in -> person_in; -- przekierowujemy output z controllera na zewnętrzny port naszego systemu
			
			A8: BUS ACCESS mem_bus -> cpu.mem_bus;
			A9: BUS ACCESS mem_bus -> RAM.mem_bus;
	  properties
		Actual_Processor_Binding => (reference (cpu)) applies to controller;
		Actual_Memory_Binding => (reference (ram)) applies to controller;
	end room.standard_room;
	
	
	-- Część z monitorowanym obiektem
	
	device alarm
		features
			turn_on_alarm: in event port;
	end alarm;
	
	system monitored_object
		
	end monitored_object;
	
	process monitored_object_controller
		features
			person_in: in event port;
			turn_on_alarm: out event port;
	end monitored_object_controller;
	
	
	
	system implementation monitored_object.target_obj
		-- przykład monitorowanego systemu, który składa się z trzech pokoi, sterownika oraz alarma.
		-- system działa w taki sposób, że przekazuje dane do sterownika w przypadku jeśli do któregoś z pokoi wejdzie osoba.
		subcomponents
			room_1: system room.standard_room;
			room_2: system room.standard_room;
			room_3: system room.standard_room;
			controller: process monitored_object_controller;
			alarm: device alarm;
			
		    cpu : PROCESSOR cpu;
			mem_bus: BUS mem_bus;
			RAM: MEMORY RAM;
		connections
			C1: port room_1.person_in -> controller.person_in;
			C2: port room_2.person_in -> controller.person_in;
			C3: port room_3.person_in -> controller.person_in;
			C4: port controller.turn_on_alarm -> alarm.turn_on_alarm;
			
			A8: BUS ACCESS mem_bus -> cpu.mem_bus;
			A9: BUS ACCESS mem_bus -> RAM.mem_bus;
	  properties
    	Actual_Processor_Binding => (reference (cpu)) applies to controller;
		Actual_Memory_Binding => (reference (ram)) applies to controller;
    	
	end monitored_object.target_obj;
	
end room;